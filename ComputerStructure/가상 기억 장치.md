가상 메모리 : 용량이 큰 보조 기억 장치를 주기억 장치처럼 사용

주소 매핑 : CPU가 참조하는 가상 주소를 주기억 장치의 실주소로 변환
주소 공간 : 가상주소의 집합
물리 주소 = 주기억 장치 주소 -> 물리 주소 집합 = 메모리 공간

매핑 방식 : 페이지 매핑, 기억 장치 매핑, 세그먼트 매핑

    페이지 매핑 : 주소 공간을 일정한 크기로 나눈 페이지, 메모리 공간을 일정하게 나눈 것이 블록
    동적 주소 변환 : 큰 주소 공간이 작은 메모리 공간을 자동 변환
        요구 페이징 : 보조 기억 장치 페이지가 필요 시에만 주기억 장치에 적재
        페이지 오류 : 가상 주소 페이지가 주기억 장치에 존재하지 않음 -> 자주 발생하면 thrashing
        각 가상 주소는 페이지 번호와 페이지 내 시작 주소인 변위가 존재한다. 페이지 번호는 매핑표에서 물리 주소를 가리키는 블록 번호와 현존 비트(페이지가 주기억 장치로 전송되었는지 여부, 1이면 주기억 장치에 존재)와 매핑되어있어서 물리 주소를 참조하여 주기억 장치에 접근한다. 매핑표의 워드 내용은 메모리 테이블 버퍼 레지스터로 전송되고 현존 비트가 1일 경우 변위와 함께 주기억 장치의 MAR로 전송된다. 제어 신호가 보내지면 워드 내용이 MBR에 저장되어 CPU가 사용. 현존 비트가 0이면, 주기억 장치에 페이지가 없는 것이므로 운영체제가 보조 기억 장치에서 주기억 장치로 페이지를 옮기고 1비트일 때의 행동을 그대로 진행한다.
    -> 이러한 페이지 매핑 기법은 낭비되는 메모리가 많아 비효율적 -> 연관 기억 장치를 사용 -> 매핑표의 워드 수와 주기억 장치 블록를 같게함
    
    연관 주소 매핑 : 키 값을 사용하여 인자 레지스터와 키 레지스터의 값으로 값을 비교하여 물리 주소를 찾아낸다.

    세그먼트 매핑 : 프로그램과 데이터를 세그먼트라는 논리 부분으로 나눔. 세그먼트가 추가된 가상 주소를 세그먼트 주소라고 한다.
    세그먼트 번호와 페이지 번호를 더해 페이지 표의 블록 번호를 얻어냄. 블록 번호와 변위를 조합하여 물리 주소를 만들어냄.

페이지 교체 알고리즘 : 페이지 오류 발생 시에 주기억 장치가 꽉 차있다면, 제거할 페이지를 선택할 알고리즘
페이지 교체 시 내용이 수정되었다면 보조 기억 장치에 수정된 사항을 쓰고 아니라면 주기억 장치에서 삭제하면 됨.

    FIFO : 제일 오래된 페이지를 교체
    LRU : 최근 가장 오래 쓰지 않은 페이지를 교체. 카운터를 둠
    LFU : 가장 적게 쓰인 페이지를 교체
    NUR : 최근 사용하지 않은 페이지 교체. 참조 비트 사용

연관 기억 장치 : 메모리 일부분을 사용해 데이터의 위치를 얻어냄. CAM, 병렬 탐색 기억 장치가 존재.

    인자 레지스터 : 검색 데이터 저장
    키 레지스터 : 인자 레지스터의 마스크 제공, 키 레지스터의 비트가 모두 1이면 인자 레지스터의 워드를 기억 장치와 비교.
    내용이 같으면 매치 레지스터의 값이 1로 설정.
    매치 레지스터 : 1비트로 구성, 1로 설정 되어있다면 기억 장치 워드 읽음