폰노이만 구조 : 프로세서(제어장치, 산술 논리 연산 장치, 레지스터 세트)가 주소, 데이터, 제어 신호를 메모리와 주고 받고
이에 대한 입출력으로 입출력 장치를 추가로 필요로 하게 된다.
프로세서, 메모리, 입출력 장치는 버스로 연결된다.
프로세서 내부는 내부 버스로, 외부는 시스템 버스로 연결됨.

프로세서 : 산술논리연산장치, 제어 장치, 레지스터 세트로 구성된다.
    산술논리연산장치(ALU) : 기본연산수행
    제어 장치(Control Unit) :장치 제어 신호 발생
    레지스터 : 프로세서 내 용량은 작지만 매우 빠른 메모리. 다양한 레지스터를 통틀어 레지스터 세트라고 함
    다음 실행할 명령어 주소를 저장하는 프로그램 카운터(pc), 현재 실행 중인 명령어 주소를 저장하는 명령 레지스터(IR)

프로세서 명령 실행 순서
    1. 메모리에서 명령 레지스터로 명령어 읽음
    2. 프로그램 카운터에서는 다음 명령어를 저장
    3. 제어 장치는 방금 가져온 명령어를 해독하고 유형 결정
    4. 메모리에 있는 데이터를 사용하는 경우 그 위치 결정
    5. 데이터를 메모리에서 레지스터로 가져옴
    6. 명령어 실행
    7. 다시 1단계로 돌아가서 다음 명령어 실행
인출 -> 해독 -> 실행 사이클로 진행
단순한 명령어 여러 개보다 복잡한 명령어 1개 사용이 더 빠름.

산술 논리 연산 장치 : 산술 연산과 논리 연산을 처리

산술 연산은 가산기를 기반으로 작동. 뺄셈은 2의 보수를 만들어 더하고 곱셈과 나눗셈은 덧셈과 시프트 반복.
지연 이슈로 전가산기나 캐리 예측 가산기를 사용하기도 함.

2진수 곱셈은 부스 알고리즘 사용
    1. 레지스터 설정. A는 누적값, Q는 곱하는 값, Q(-1)은 Q의 이전 마지막 비트 저장. n은 M의 비트 수
    2. Q와 Q(-1) 모두 0 또는 1이면 아무것도 하지 않고,
    Q = 0 이고 Q(-1) = 1이면 A = A + M
    Q = 1 이고 Q(-1) = 0이면 A = A - M
    3. 모든 레지스터를 오른쪽 시프트 연산, A의 부호 비트는 유지, Q의 마지막 비트는 Q(-1)에 저장
    4. 위 과정은 n번 반복

레지스터 : 데이터와 명령어를 빠르게 읽고 쓰기 위해 사용하는 cpu내 메모리이다. 메모리 계층 최상층이며 가장 빠른 메모리.
시스템에서 작업 수행동안 사용. 주기억 장치에서 데이터를 읽어서 레지스터에 저장하고 처리가 끝나면 주기억 장치에 다시 저장.
데이터 레지스터는 8-128개, 특수 레지스터는 8-16개

메모리 주소 레지스터 : cpu가 읽고 쓰기 위한 데이터 메모리 주소 저장. 메모리 위치의 주소를 MAR로 보냄
메모리 버퍼 레지스터 : 메모리 데이터 레지스터(MDR)이라고도 불리며, 메모리에서 가져오거나 메모리에 저장할 데이터 또는 명령어를 저장
입출력 주소 레지스터 : I/O 모듈과 프로세서 간 데이터 교환
프로그램 카운터(PC) : 명령 포인터 레지스터라고도 불림. 실행을 위해 인출할 다음 명령의 주소를 저장하는데 사용.
항상 가져올 다음 명령의 주소를 가르키거나 유지
명령 레지스터(IR) : 주기억 장치에서 인출한 명령어 저장
누산기 : ALU 내부에 위치. 산술과 논리 연산에 사용. 주기억장치에서 인출된 데이터 값을 저장. 초기 데이터, 중간 결과 및 최종 연산 결과를 저장. 최종 결과는 목적지 레지스터나 MBR을 이용하여 주기억 장치로 전송
스택 제어 레지스터 : 메모리 스택 관리
플래그 레지스터 : 특정 조건 발생 표시. 상태 레지스터와 프로그램 상태 워드라고도 한다.
데이터 레지스터 : 주변 장치로부터 전송되는 데이터를 일시적으로 저장하기 위해 프로세서에 사용되는 레지스터.

레지스터 전송 : 레지스터로 데이터를 읽어오는 LOAD, 레지스터에서 주기억 장치로 데이터를 저장하는 STORE, 레지스터에서 레지스터로 데이터를 이동하는 MOVE.

명령어 형식 : 명령어는 연산 코드(opcode)와 피연산자(operand) 위치, 연산결과 저장 위치 등 여러 가지 정보로 구성된다.

0-주소 명령어 : 오퍼랜드와 결과가 모두 스택에 저장

1-주소 명령어 : 연산 대상 2개 중 하나만 표시하고 나머지는 누산기에 사용. 연산 결과는 AC에 저장.
ADD X : AC <- AC + M[X] => 기억 장치 X번지의 내용과 누산기의 내용을 더하고 그 결과를 다시 누산기에 저장

2-주소 명령어 : 두 오퍼랜드의 저장 장소 중 하나가 결과값을 저장하는 용도로 사용.
ADD R1, R2 : R1 <- R1 + R2

3-주소 명령어 : 오퍼랜드 2개와 결과 값의 저장 장소가 모두 다름.
ADD R1, R2, R3 : R1 <- R2 + R3

ADD, MUL, MOV(레지스터와 기억 장치 간 이동), LOAD(기억 장치에서 데이터를 읽어 누산기에 저장), STOR(AC의 내용을 기억 장치에 저장)

프로세서 성능 향상 -> 명령어 길이 최소화 -> 명령어 길이가 실행 속도 제한 -> 짧은 명령어는 빠른 프로세서 -> 여러 개의 명령을 실행하므로 클록 주기당 명령어를 여러 개 가져오는 것이 중요

명령어의 종류
    데이터 이동 : 원본과 똑같은 객체 복사, 없어지는 것이 아닌 다른 장소에 복사본 생성
    2항 연산 : 오퍼랜드 2개를 결합하여 결과 생성. 논리연산과 비트 연산, 산술 연산
    단항 연산 : 오퍼랜드가 1개, 결과 1개. 시프트 연산
    비교 조건 분기 명령 : 데이터 검사 결과에 따라 명령 순서 변경
    프로시저 호출 명령 : 특정 작업을 수행하는 명령 그룹. 프로그램 내 어디서든 호출 가능. 어셈블리에서는 서브루틴, java에서는 메소드라고 불린다.
    루프 제어 명령 : 루프를 통해 정해진 횟수만큼 명령 그룹 실행
    입출력 명령 : 프로그래밍 입출력, 인터럽트, DMA(Direct Memory Access)

주소 지정 방식 : 오퍼랜드 위치를 지정
    즉시 주소 지정 : 명령어 자체에 오퍼랜드 포함, 상수만 가능, 메모리 참조x
    직접 주소 지정 : 오퍼랜드 전체 주소 지정. 항상 동일한 메모리 위치 액세스. 값은 변하나 위치는 변하지 않음. 주소의 전역 변수 액세스에만 사용
    레지스터 주소 지정 : 직접 주소 지정과 같지만 레지스터 사용
    레지스터 간접 주소 지정 : 메모리에서 LOAD나 MOV를 하지만 직접 주소를 명령어에 포함하지 않는다.
    메모리 주소는 레지스터에 저장 -> 포인터(레지스터 값 자체가 메모리 주소). 명령어에 전체 메모리 주소가 없어도 메모리 참조 가능.
    변위 주소 지정 : 특정 레지스터에 저장된 주소에 offset을 더해 실제 오퍼랜드가 저장된 메모리 위치 지정.
    기존 주소에서 offset만큼 떨어진 위치도 접근 가능(배열, 구조체 등)
    간접 주소 지정 : 메모리를 이중 참조. 먼저 지정된 주소를 읽어서 실제 저장된 주소를 읽고, 그 주소로 다시 접근하여 데이터 접근
    데이터를 간접적으로 접근하게 되므로 메모리 위치를 동적으로 관리할 수 있음.(다단계 포인터, 동적 메모리, 배열이나 구조체 내에서 간접 참조)

CISC(Complex Instruction Set Computing) : 복잡한 명령어의 조합으로 한 명령어로 여러 단계 처리 가능. 고급 프로그래밍(C/C++, JAVA 등)언어와 호환성. 길이가 고정되지 않음. 복잡한 명령어 설계로 CPU내 많은 회로가 포함됨. 메모리에 직접 접근 가능함. 또한 다양한 명령어 지원. 대표적으로 Intel x86 Architecture가 있음.

RISC(Reduced Instruction Set Computing) : 단순 명령어 집합. 명령어 종류가 적고, 간단한 작업만 수행. 명령어 길이가 고정되어 있어 실행시간이 일정함. 복잡한 작업은 컴파일러(소프트웨어)가 처리하도록 설계. 메모리보다는 레지스터를 사용. 클럭 사이클 당 한번씩만 실행. 메모리 사용량이 높고 호환성이 낮음. 대표적으로 ARM 프로세서