제어 장치 : 컴퓨터의 모든 동작 제어. opcode를 기반으로 제어 신호 생성
제어신호는 하드웨어에게 수행할 작업을 알려준다.

제어 장치 기본 기능
    CPU에 접속된 장치들에 대한 데이터 이동 순서 조정
    명령어 해독
    CPU내 데이터 흐름 제어
    외부 명령을 받아 일련의 제어 신호 생성
    CPU내 장치 제어
    명령어 인출, 해독, 실행 처리

제어 장치 종류 : 하드와이어 제어 장치, 마이크로 프로그램 제어 장치

하드와이어 제어 장치 : 디코더, 플립플롭, 논리 게이트 등의 조합 논리 회로로 만들어진 하드웨어. 명령어 실행 제어. 물리적 변경 외에는 신호 생성 방법 수정 불가.
CPU 내 명령 레지스터(IR)에 저장된 명령어를 디코딩
opcode를 확인하여 연산 수행 결정
fetch -> decode -> execute -> write back에 필요한 신호를 논리 회로를 통해 생성
클럭 신호를 기반으로 제어 신호가 순차적으로 실행, cpu동작 동기화

하드와이어 제어 장치 구조 : 명령어 디코더, 클럭 생성기, 조합 논리 회로, 상태 레지스터
소규모 임베디드 시스템이나 특화된 하드웨어 가속기에 사용

마이크로 프로그램 제어 장치 : 명령어 실행 순서인 해독된 제어 신호를 비트 패턴으로 만들어 제어 메모리에 저장해둔다.
주기억 장치에서 레지스터로 다음 명령어를 가져온다는 점에서 하드와이어 제어 장치와 같지만, opcode를 해독하지 않고 제어 메모리의 제어
주소 레지스터로 전송되어 마이크로 명령 레지스터에 읽히게 된다.

1. 명령 레지스터에서 저장된 명령어를 분석하고 해당 명령어에 맞는 마이크로명령어의 시작 주소를 결정한다.
2. 제어 메모리에 접근하여 저장된 마이크로명령어를 읽고 CPU내 각 구성요소에 전달할 제어 신호를 생성.
3. 이를 명령어가 끝날 때까지 해당 마이크로명령어를 순차적으로 제어 메모리에서 읽어와서 실행함(각 마이크로명령어는 명령어 실행의 작은 단계에 해당함)
4. 명령어가 끝나면 다음 명령어 실행을 위해 초기 단계로 돌아감

마이크로 프로그램 제어 장치 구조 : 제어 메모리(마이크로명령어가 저장됨), 마이크로명령어(제어 신호를 위한 작은 명령어 단위), 마이크로프로그램(명령어 실행을 위한 마이크로명령어의 집합), 마이크로 프로그램 카운터(마이크로명령어 위치 추적), 제어 신호 생성기(마이크로명령어 해석 후 신호 생성)

마이크로 프로그램 동작 과정 : 명령어 디코딩(opcode분석, 마이크로 프로그램 시작 주소 확인, 사상함수에 opcode 연결) -> 제어 메모리 접근(마이크로 프로그램 카운터가 가리키는 주소에서 마이크로명령어를 읽어옴) -> 제어 신호 생성(마이크로명령어 비트 필드 해석 후 신호 생성) -> 다음 마이크로명령어 실행 -> 명령어 실행 완료

복잡한 명령어 집합을 지원해야하는 범용 프로세서에서 사용됨

명령어 사이클(데이터 경로 사이클)
명령어 인출 -> 명령어 해독 -> 명령어 실행

명령어 인출 : CPU가 명령어를 메모리에서 가져오는 단계. 프로그램 카운터(PC)에서 MAR로 명령어 위치를 보냄.
주소버스로 주기억 장치에 전송. 저장된 명령어를 데이터 버스를 통해 MBR에 저장. 명령 레지스터(IR)에 저장.

명령어 해독 : IR에서 opcode만 해독기에 전달, 마이크로 루틴 해석

명령어 실행 : operand를 주기억 장치에서 찾아 데이터를 읽고 레지스터(혹은 누산기)에서 읽어서 마이크로 명령어 순차 실행
명령어 종류 : ISZ, BSA

인터럽트 사이클 : 실행 주기마다 인터럽트가 발생하였는지 확인

프로세서의 기본 장치는 ALU, 레지스터, 내부 데이터 경로, 외부 데이터 경로, 제어 장치이다.
프로세서의 연산은 일련의 마이크로 연산들로 구성됨. 모든 마이크로 연산은 다음 중 하나임
    - 한 레지스터에서 다른 레지스터로의 데이터 전송
    - 레지스터에서 외부 인터페이스(시스템 버스 등)로 데이터 전송
    - 외부 인터페이스에서 레지스터로 데이터 전송
    - 입력 및 출력 레지스터를 사용하여 산술 또는 논리 연산 수행
제어 장치는 순서와 실행이라는 기본 작업을 수행한다. 명령어 사이클을 관리한다.

파이프 라이닝 : 현대 대부분의 프로세서에서는 명령어 하나를 여러 단계로 나누어 각각 독립적인 장치에서 동시에 실행하는 기술

5단계 파이프 라이닝 : 명령어 인출(IF) -> 명령어 해독, 오퍼랜드 인출(ID) -> 명령어 실행(EX) -> 메모리에서 데이터 읽거나 저장(MEM) -> 연산 결과 레지스터에 기록(WB)  순서에 따라 여러 개의 명령어를 병렬적으로 처리함.

그러나 실제로는 이를 방해하는 요소인 해저드가 존재

    1. 데이터 해저드 : 명령어 간의 데이터 의존성에 의해서 발생함. 앞서가는 명령 결과가 레지스터에 기록을 하기도 전에 다른 명령어가 해당 데이터를 필요로 하는 상황에서 발생함 -> 데이터 포워딩으로 이전 명령어 결과를 다음 명령어에 즉시 전달하거나 명령어 사이에 버블을 끼워넣어 단계를 지연시키거나 잠시 멈추는 스톨을 사용.
    RAW(read after write) : 쓰기가 끝나기도 전에 읽으려고 할 때 발생 (스톨, 버블과 데이터 포워딩으로 해결)
    WAW(write after write) : 두 명령어가 같은 값을 쓰려고 할 때 발생, 순서 오류
    WAR(write after read) : 읽기 전에 데이터가 미리 써질 경우 발생
    WAR, WAR 모두 Data Renaming으로 해결 -> 논리적 레지스터와 물리적 레지스터 분리

    2. 제어 해저드 : 분기 명령어로 인해 발생함. 분기에 의해 다음 명령어를 예측할 수 없어 성능 저하가 발생하거나 잘못된 명령어를 실행하는 경우가 발생. 추가 사이클을 요구하거나 Flush 작업을 수행해야함 -> 분기를 예측하거나 분기 타겟 버퍼를 만들어 반복된 분기를 캐시에 저장, 분기 명령어 이후 항상 실행되는 명령어를 설계해 지연, 모든 경로를 실행해보고 올바른 결과를 선택하는 방식
   
    3. 구조적 해저드 : 하나의 하드웨어 자원이 동시에 두 개 이상의 명령어에 의해 사용되어 충돌이 발생. 단일 메모리나 단일 연산장치를 사용 시 발생 -> 하버드 구조를 사용하거나 분리 캐시를 만들어 사용.

슈퍼 스칼라 : 한번의 클럭 주기 동안 여러 개의 명령어를 동시에 처리할 수 있는 명령어 병렬 처리 아키텍처 -> 하드웨어 레벨의 병렬 처리 기술, CPU내 여러 실행 유닛(ALU, 메모리, FPU)을 독립적으로 분리한 다중 실행 유닛에 의해 명령어를 병렬처리 가능, 한 번에 여러 개의 명령어를 해석하고 적절하게 다른 유닛에 분배 가능