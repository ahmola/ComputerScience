HTTP/1.1은 구현 단순성과 접근성을 두고 만들어져 성능이 좋지 못했다. 응답을 받아야만 다음 요청을 보낼 수 있기 때문에 심각한 회전 지연이 발생했다. 이를 위해 병렬 커넥션과 파이프라이닝이 도입되었지만 근본적인 해결책이 되지는 못했다.

구글은 성능 개선을 위해 SPDY라는 프로토콜을 내놓았다. 헤더를 압축하여 대역폭을 절약하고 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄였으며 요청을 보내지 않아도 능동적인 리소스 푸시 기능도 갖추었다. 이를 기반으로 HTTP/2.0프로토콜의 초안이 만들어졌다.

HTTP/2.0은 TCP 커넥션에서 동작하며 초기화는 클라이언트가 담당한다. 요청과 응답은 한 프레임에 담기며 HTTP 헤더는 압축되어 담긴다.

프레임은 스트림을 통해 보내진다. 한 스트림에 요청과 응답을 쌍으로 처리하고 스트림 여러 개가 동시에 한 커넥션 위에서 만들어진다. 여기에 스트림에 흐름 제어와 우선순위를 부여한다. 클라이언트는 스트림을 만들어 HTTP 요청을 보내고 서버는 요청과 같은 스트림에 응답으로 보낸다. 그 후 스트림이 닫히게 된다.

서버 푸시 모델을 도입하였는데 이는 클라이언트에게 필요하다고 판단되는 리소스는 요청을 받지 않아도 클라이언트에게 보낼 수 있다. HTML 문서 내에 동영상이나 사진 파일 등이 존재할 때 이는 클라이언트가 다시 요청할 확률이 높으므로 서버는 리소스를 클라이언트가 요청하지 않아도 한꺼번에 보내는 방식이다. 서버는 PUSH_PROMISE 프레임을 보내 클라이언트에게 미리 보낼 것을 알리고 만약 거절하고 싶다면 클라이언트 쪽에서 RST_STREAM 프레임을 보내 거절할 수 있다.

호환성을 위해 요청과 응답 메세지의 의미는 HTTP/1.1과 같게 유지하였다.

