트랜잭션 : SQL문들을 묶은 하나의 처리 단위. 하나라도 오류가 발생하면 전체 취소 후 rollback, 정상 종료 시 commit된다.
커밋되기 전까지는 임시 실행 결과일 뿐이다.

    원자성 : 모두 성공적으로 실행하거나 모두 철회하여 무효화

    일관성 : 실행 전 후 일관된 상태 유지

    고립성 : 다른 트랜잭션에게 공개되지 않는 간섭 방지

    지속성 : 장애가 발생하더라도 보존. 손상 이전 상태 회복

DBMS 지원 모듈 : 간섭 제어하고 일관성 유지, 결과 복구 보장

트랜잭션 종류

    명시적 트랜잭션 : 사용자가 직접 명시적으로 지정
        START TRANSACTION;
            SQL 명령문
        {COMMIT | ROLLBACK};
    
    자동완료 트랜잭션 : 특별한 설정이 없는 경우 적용. 하나의 SQL문마다 개별 트랜잭션 처리
        SELECT @@AUTOCOMMIT;
        SET AUTOCOMMIT = 1;
    각 SQL 앞에는 START TRANSACTION, 뒤에는 COMMIT이 자동으로 추가된다.

    수동완료 트랜잭션 : 트랜잭션의 끝만 사용자가 명시적으로 지정
        CREATE, ALTER, INSERT, UPDATE, DELETE, SELECT, DROP, FETCH, GRANT, OPEN, REVOKE, TRUNCATE TABLE
    위 명령문들은 START TRANSACTION이 없어도 트랜잭션이 자동으로 시작된다. DML 문장이 실행됨과 동시에 트랜잭션 시작
        SELECT @@AUTOCOMMIT;
        SET AUTOCOMMIT = 0;
    로 설정하여 수동완료 트랜잭션으로 설정한다. COMMIT 또는 ROLLBACK 명령문을 반드시 써야함.

트랜잭션 처리 과정

    데이터 변경 요청 -> DBMS -> 쿼리처리기를 통해 SQL문 해석 -> 디스크 db파일에서 주기억장치 db버퍼 캐시로 옮겨짐
    -> 데이터 변경 -> 디스크 db파일에 쓰기(즉시 반영x)

장애 발생 시 복구를 위해 로그가 매 트랜잭션 처리마다 로그 db파일에 기록

저장 db파일에 반영하기 전에 미리 로그 db파일에 트랜잭션 데이터 변경 사항을 저장함.

별도로 저장하는 백업 데이터베이스를 둔다. 이 백업 데이터베이스를 이용해 원래 상태로 되돌리는 작업을 복원이라고 한다.

동시성은 비직렬 스케쥴과 트랜잭션의 결과가 뒤섞이지 않아 직렬 스케쥴과 결과가 같도록 보장되어야 한다.
이러한 동시성을 만족하는 트랜잭션 스케쥴을 serializable이라고 한다.

락 : 데이터베이스의 데이터를 다른 사용자가 접근하지 못하도록 잠그는 것

락의 종류

    shared lock : SELECT문 실행 시 읽기 전용 락. 읽기만 가능하고 수정 불가
    다른 공유락과 양립하지만 독점락과는 양립 불가

    exclusive lock : INSERT, UPDATE, DELETE문과 같은 데이터 변경을 위한 배타적 락
    오직 하나의 트랜잭션만 독점 락 가능. 어떠한 락과도 양립 불가

2단계 락킹 규약

    1단계 : 락 확장 단계. 데이터에 대한 모든 락을 흭득할 때까지 새로운 락을 지속적으로 요청하여 잠금 설정
    보유 락 해제 불가, 락 흭득만 가능

    2단계 : 락 축소 단계. 모든 락을 흭득한 lock point가 되면 점차적으로 락 해제
    하나씩 해제하거나 한꺼번에 락을 해제. 하나라도 해제하기 시작하면 새로운 락을 요청할 수 없음

트랜잭션 교착 상태 : 두 트랜잭션이 똑같이 두 데이터에 각각 공유 락과 독점 락을 요청하면 두 트랜잭션 모두
서로 다른 데이터를 독점함과 동시에 서로 다른 데이터를 대기하는 교착 상태가 발생함.
=> 순서에 따라 차례대로 락을 흭득, SQL문 최소화, 가장 적은 시간을 소요하는 트랜잭션을 희생시켜 롤백
