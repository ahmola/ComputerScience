가상 메모리 : 물리 메모리의 크기와 상관없이 프로세스에 커다란 메모리 공간을 제공

가상 주소 : 가상 메모리 내에서 존재하는 0번지부터 시작하는 연속된 가상의 주소 공간

물리 메모리 내용 일부를 보조 기억 장치의 일부인 스왑 영역으로 옮긴다. 스왑은 메모리 관리자가 관리하고 가상 메모리의 구성 요소 중 하나이다. 부족한 공간을 스왑 영역을 통해 보충한다. 메모리가 꽉차면 프로세스를 스왑 영역으로 보내고 swap out을 하고, 작업을 마치면 swap in을 한다.

동적 주소 변환 : 물리 메모리와 스왑 영역을 합쳐서 프로세스가 사용하는 가상 주소를 실제 메모리 주소로 변환하는 방법

가상 메모리 시스템은 세그멘테이션 기법과 페이징 기법을 혼용해서 사용한다. 메모리 관리 시 매핑 테이블을 작성한다.

    페이징 기법 : 고정 분할 방식으로 가상 메모리를 분할한 각 영역을 페이지라고 한다. 구분을 위해서 물리 메모리의 각 영역을 프레임이라고 한다. 페이지와 프레임의 크기는 같고 덕분에 페이지는 어떤 프레임과도 연결될 수 있다.
    
    페이지 테이블을 만들어 매핑 정보를 저장한다. 페이지 테이블의 한 줄을 엔트리라고 부른다. 각 엔트리의 번호는 페이지의 번호와 일치하고 프레임 번호가 저장되어 있다. 물리 메모리의 운영체제 영역 일부에 놓인다. 각 프로세스는 페이지 테이블을 하나씩 갖는다.

        1. 가상 주소가 어느 페이지에 있는지 찾아낸다.
        
        2. 페이지 테이블에서 해당 페이지로 가서 어느 프레임이 위치한지 찾아낸다.

        3. 해당 프레임에서 페이지의 위치에 해당하는 실제 위치를 찾아낸다.

    VA = <P, D> -> PA = <F, D> => VA는 가상주소, PA는 물리 주소, F는 프레임, P는 페이지, D는 변위를 나타낸다.

    페이지 테이블의 전체 크기는 프로세스의 수에 비례하여 커진다. 페이지 테이블 수가 늘어나거나 페이지 테이블 크기가 커지면 물리 메모리의 운영체제 영역이 그만큼 늘어나서 사용자 영역이 줄어들게 된다. 물리 메모리 크기가 작다면 프로세스뿐만 아니라 페이지 테이블도 스왑 영역으로 옮겨지게 된다. 페이지 테이블에 빠른 접근을 위해 Page Table Base Register가 존재한다.

    페이지 매핑 방식은 전체를 메모리에서 관리하는지, 일부를 스왑 영역에서 관리하느냐에 따라 달라진다.

        직접 매핑 : 테이블 전체가 물리 메모리 운영체제 영역에 존재. 즉시 주소 변환 가능

        연관 매핑 : 테이블 전체를 스왑 영역에서 관리. 메모리 여유 공간이 적을 때 사용함. 일부만 무작위(translation look-aside buffer)로 물리 메모리에서 가지고 있음. 물리 메모리 내의 페이지 테이블을 다 검색해야 한다. 없다면 스왑 영역에서의 테이블을 검색.

        집합-연관 매핑 : 연관 매핑 문제 개선. 테이블 관리 방식은 연관 매핑과 같지만, 페이지 테이블을 일정 크기로 잘라서 집합으로 묶는다. 집합은 디렉터리 테이블을 새로 만들어서 관리한다. 디렉터리 테이블은 집합(자른 테이블)이 물리 메모리에 있다면 물리 메모리 주소를, 스왑 영역에 있다면 I로 표시한다. 이를 통해 간단하게 찾고자 하는 페이지가 물리 메모리에 있는지 없는지 빠르게 파악할 수 있다. VA = <P1, P2, D>로 표시하여 두 단계를 거쳐서 물리 주소로 변환한다. 즉, 처음에는 디렉터리 테이블에서 P1을 찾아서 이동하고 P1에 부분 테이블이 물리 메모리에 있다면 해당 시작 주소를 통해 부분 테이블의 P2로 이동하고, 물리 메모리 주소로 이동하여 값을 찾아낸다. 크기가 큰 페이지 테이블을 집합으로 나눠서 디렉터리 테이블로 관리하기 때문에 효율적이다.

        역매핑 : 프레임 번호를 기준으로 테이블을 구성. 해당 프레임에 어떤 프로세스가 올라와있는지(PID)를 표시함. 프로세스 수와 상관없이 테이블이 하나만 존재함. 테이블 크기가 작다. 그러나 프로세스가 PID와 페이지 번호를 모두 검색해야 한다.

    세그멘테이션 기법 : 가변 분할 방식으로 세그멘테이션 매핑 테이블을 통해 세그먼트를 관리한다. 테이블에는 세그먼트 크기인 limit와 물리 메모리 시작 주소인 address가 있다. 스왑 영역을 사용하며 테이블이 작고 단순하지만 메모리 관리가 복잡하다. 
    VA = <S, D>로 가상 주소를 표현하며, S는 세그먼트 번호, D는 변위를 나타낸다. 세그먼트의 시작 주소에 변위를 더해서 물리 주소를 찾아낸다. 즉, PA = S의 시작 주소 + D 이다. 
    limit보다 더 큰 주소에 접근하면 프로세스를 강제로 종료하는데 이를 trap이라고 한다.

    세그멘테이션-페이징 혼용 기법 : 프로세스는 물리 메모리 상에서 PCB와 코드(read/execute), 데이터(read/write), 스택 영역(read)으로 나뉘어서 실행되게 된다. 이는 가상 메모리 상에서도 똑같이 적용된다. 그러므로 페이지마다 접근 권한도 다르므로 페이지 테이블에는 메모리 접근 권한과 관련된 권한 비트가 추가된다. 세그멘테이션-페이징 혼용 기법에서는 기본적으로 페이징 기법을 사용하되, 접근 비트외 다른 권한관 관련된 정보를 세그멘테이션 테이블로 만들어 각 메모리 영역의 시작 주소를 저장한다. 
    VA = <S, P, D>로 가상 주소를 표현하며 S는 세그먼트 번호, P는 페이지 번호, D는 변위이다. S를 통해 세그멘테이션 테이블에서 접근하여 페이지 테이블의 시작 주소를 찾는다. 여기서 페이지 테이블로 이동하여 P만큼 이동하여 페이지를 찾고 물리 메모리의 시작 주소를 찾아 D만큼 이동하여 데이터를 찾는다. 없다면 기존과 마찬가지로 스왑 영역에서 찾는다.

요구 페이징 : 프로세스가 요청할 때 페이지를 메모리로 가져오는 방법. 대표적으로 캐시가 있음. 사용자가 요구할 때까지 페이지를 메모리로 가져오는 것을 최대한 미룬다.

Page Fault : 페이지 요청 시 메모리에 페이지가 없는 경우. 페이지 테이블에서 해당 페이지의 유효 비트가 1인 경우
이러한 페이지 부재 발생 시 메모리 빈 영역에 스왑 영역에서 가져온 페이지를 갱신한다. 만약 메모리에 공간이 없어서 하나의 페이지를 스왑 영역으로 내보내야할 때는, 메모리의 페이지 중 하나를 선택해야 한다. 이 때 페이지 교체 알고리즘 사용하며 스왑 영역으로 보낼 페이지를 
victim page라고 한다. 

세그멘테이션 오류는 다른 프로세스의 메모리 영역을 침범해서 침범한 프로세스를 강제 종료하게 되는 오류이고 페이지 부재는 메모리에 페이지가 없어서 발생하는 오류로 프로세스와 무관하다.

victim page를 선택할 때는 현재 데이터와 얼마나 가까운지(공간의 지역성), 얼마나 가까운 시간에 접근했는지(시간의 지역성), 순서대로 진행되는지(순차적 지연성)를 고려해야한다.

페이지 교체 알고리즘(Page Replacement Algorithm)

    Random : 무작위로 스왑아웃할 페이지를 선택한다. 

    FIFO : 선입선출식. 가장 먼저 들어온 페이지를 스왑 아웃한다. 페이지 부재가 발생하면 F, 아니면 S로 표시한다.

    Optimal :  앞으로 사용하지 않을 페이지를 스왑아웃함. 그러나 실제로 이러한 예측은 불가하므로 구현 불가

    LRU(Least Recently Used) : 접근한(read, write, execute 등) 시간을 기록하여 가장 오래 사용하지 않은 페이지를 교체한다. 시간뿐만 아니라 카운터, 비트를 접근할 때마다 1로 바꿔 오른쪽으로 한 칸씩 이동시키는 참조 비트 방식이 있다.

    LFU(Least Frequently Used) : 페이지가 몇 번 사용되었는지를 기록하여 가장 적게 사용된 페이지를 스왑아웃할 페이지를 선택한다.
    
    NUR(Not Used Recently) : 최근에 사용하지 않은 페이지를 교체한다. LFU와 다르게 추가 비트 2개만(참조 비트와 변경 비트) 사용. 참조가 변경보다 후순위이며, 두 개의 비트가 (0,0)인 비트가 최우선적으로 변경된다. (0, 1), (1,0), (1, 1)순으로 스왑아웃한다. (1, 1)가 되면 비트를 (0, 0)으로 초기화한다. 가장 많이 사용되는 알고리즘

    FIFO 변형 : 기본적으로 FIFO 알고리즘을 쓰되 접근할 때마다 순서의 변화를 줌. 2차 기회 방식과 시계 방식이 있다.

        2차 기회 : 페이지 부재 없이 성공한 페이지를 큐의 맨 뒤로 옮김

        시계 : 원형 큐를 사용. 스왑아웃할 페이지를 가리키는 포인터가 존재. 해당 포인터는 큐의 맨 밑바닥으로 내려가면 다시 큐의 처음 부분을 가르킨다. 참조 비트가 존재하며 참조에 성공하면 0에서 1로 변경된다. 참조 비트가 1인 비트는 0으로 바꿈과 동시에 건너뛰고 바닥에 도착하면 다시 큐 상단으로 간다.