프로그램 : 저장장치에 저장된 정적 상태, 어던 데이터를 사용하여 어떤 작업을 할지 절차를 적어놓은 것.
프로세스 : 실행을 위해 메모리에 올라온 동적 상태. 프로그램으로 작성된 작업 절차를 실제 실행한다는 의미.

프로세스는 테스크라고도 불린다. 프로그램이 메모리로 옮겨지면 프로세스 제어 블록(PCB)가 만들어진다. PCB는 프로세스를 처리하는데 필요한 정보가 들어가 있다. 프로그램이 프로세스가 되었다는 것은 PCB가 생성되었다는 뜻이기도 하다. PCB는 프로세스 구분자 메모리 관련 정보, 각종 중간값이 담겨있다. 메모리의 운영체제 영역에서 만들어지며 프로세스가 종료되면 PCB도 폐기된다.

운영체제 또한 프로그램으로 컴퓨터 실행 시 프로세스 형태로 실행된다. 운영체제 프로세스를 메모리에 올리는 프로그램을 부트스트랩이라고 한다. 그러므로 컴퓨터에서는 사용자 프로세스와 운영체제의 커널 프로세스가 섞여서 실행된다.

대부분의 운영체제는 시분할 시스템(프로세스가 시간 단위로 돌아가면서 운영체제 자원을 사용하는 시스템)을 사용하는데, 시분할 시스템은 생성, 준비, 실행, 대기, 휴식, 보류, 완료 일곱 가지 상태를 가진다.

    생성 상태 : 메모리에 올라와 실행 준비 완료한 상태. 프로세스 제어 블록이 생성된다.
    
    준비 상태 : 프로세스가 CPU를 얻을 때까지 기다림

    실행 상태 : 준비 상태의 프로세스 중 하나가 CPU를 얻어 작업 수행. 이 때 프로세스 중 하나를 고르는 CPU 스케줄러 작업을 디스패치라고 한다. 일정 시간(time slice, time quantom)동안 CPU 사용. 클록이 인터럽트를 사용하여 CPU에 시간이 초과됐음을 알림. 시간동안 작업이 끝나지 않았다면 준비 상태로 돌아가 다음 차례를 기다린다(time out). 이 행위는 작업이 끝날 때까지 반복된다.

    대기 상태 : 입출력을 요청한 프로세스를 실행 상태에서 옮김. CPU 스케줄러는 준비 상태에 있는 프로세스 하나를 실행 상태로 옮김. 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받으면 대기 상태의 프로세스는 준비 상태로 돌아가 다음 차례를 기다린다.

    완료 상태 : 프로세스의 작업이 완료되어 메모리에서 내려가고 프로세스 제어 블록이 사라진다.

    이 다섯 가지 상태를 활성 상태라고 함.

    휴식 상태 : 프로세스가 일시적으로 작업을 쉼. 메모리에 있음.

    보류 상태 : 프로세스가 메모리에서 잠시 나간 상태. 일시 정지 사태라고도 불림. 활성 상태와 반대되는 상황으로 메모리가 꽉 차서 일부 프로세스를 내보내야 하거나 오류가 있어서 실행을 미루어야 할 때, 바이러스라고 판단될 때, 매우 긴 주기를 가진 프로그램이라 쫓겨나도 문제가 없는 경우, 입출력이 지연될 때 발생한다. 더 있지만 대부분 성능 감소나 실행을 미뤄도 지장이 없는 프로세스를 대상으로 한다. 이렇게 내보내진 프로세스는 swap 영역에 임시로 보관된다. 보류 대기 상태와 보류 준비 상태로 구분되며 각 상태에서 재시작하면 활성 상태로 들어간다. 보류 대기 상태에서 입출력 완료 시 활성 상태가 아닌 보류 준비 상태로 옮겨진다.

프로세스 제어 블록(Process Control Block) : Task Control Block이라고도 불리며 프로세스 실행에 중요한 정보를 담은 자료 구조이다. 모든 프로세스가 가지고 있으며 프로세스 생성 시 만들어져 프로세스가 완료되면 폐기된다.

프로세스 제어 블록 구성

    포인터 : 첫 번째 블록에 저장된다. 준비 상태나 대기 상태의 큐를 구현할 때 포인터가 사용된다.

    프로세스 상태 : 두 번째 블록에 저장되며 프로세스 상태를 저장
    
    프로세스 구분자 : 프로세스를 식별하기 위한 구분자

    프로그램 카운터 : 실행될 명령어의 위치를 저장함

    프로세스 우선순위 : 프로세스는 중요도에 따라 실행 순서가 다른데 이러한 실행 순서를 정하게 해줌

    각종 레지스터 정보 : 누산기, 인덱스 레지스터, 스택 포인터 같은 레지스터들의 중간값이 저장된다.

    메모리 관련 정보 : 메모리 위치 정보, 경계 레지스터 값, 한계 레지스터 값, 세그멘테이션 테이블, 페이지 테이블 등이 보관된다.

    할당된 자원 정보 : 입출력 자원 또는 열린 파일 등의 정보를 저장

    계정 정보 : 계정 번호, CPU 할당 시간, CPU 사용 시간 등이 저장

    부모 프로세스 구분자와 자식 프로세스 구분자 : 부모 프로세스를 가리키는 PPID, 자식 프로세스를 가리키는 CPID가 저장된다.

대기 상태에서는 다양한 입출력을 기다리는 다양한 프로세스가 존재한다. 효율적인 작업을 위해 대기 상태에는 같은 입출력을 요구한 프로세스끼리 대기 큐에 모인다. 입출력이 완료되면 해당 프로세스의 제어 블록을 찾아서 제어 블록을 준비 상태로 바꾸고 큐에서 제거한 뒤 준비 큐로 이동한다.

문맥 교환 : CPU를 사용하던 프로세스가 나가고 새 프로세스를 받아들이는 작업. 두 프로세스 제어 블록 내용이 변경된다. 나가는 프로세스의 상태는 저장되고 들어오는 프로세스의 내용이 CPU에 세팅된다.

    p1 time out -> p1상태를 pcb1에 저장 -> pcb2에서 p2 상태 가져옴 -> dispatch -> p2 execute -> p2 time out -> p2상태 pcb2에 저장 -> pcb1에서 p1의 상태 가져옴 -> dispatch -> ...

프로세스의 구조

    코드 영역  : 프로세스의 본문. 읽기 전용으로 처리
    데이터 영역 : 데이터 영역과 heap 영역으로 나뉨. 변수나 파일 등의 데이터 보관. 읽기/쓰기 가능. 상수는 읽기만 가능
    스택 영역 : 부수적으로 운영체제가 관리하는 데이터 영역. 스택의 내용은 사용자가 볼 수 없다.

프로세스의 생성과 복사
프로세스를 생성하는 것뿐만 아니라 복사하는 방법도 존재한다. fork()함수를 사용하면 프로세스를 복사할 수 있다.(ctrl+N 키로 복사)
기존 프로세스는 부모 프로세스가 되고 복사된 프로세스는 자식 프로세스가 되어 부모-자식 관계로 연결된다.

메모리에서도 fork()를 호출하면 자식 프로세스에서도 부모 프로세스와 똑같은 프로세스 제어 블록이 복사된다.
그러나 서로 다른 프로세스이므로 PID, 메모리 관련 정보, 부모-자식 관계 관련 정보가 바뀐다.

fork()함수를 사용하면 프로세스 생성 속도가 빠르고, 추가 작업없이 자원 상속이 가능하며, 효율적인 시스템 관리가 가능하다.

exec()함수는 프로세스 자체는 그대로 두고 내용만 바꾸는 함수이다. 구조체를 재활용하여 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용하여 완전히 다른 프로세스로 변경이 된다. 데이터 영역에는 새로운 변수가 채워지고 스택 영역, 각종 레지스터, 사용한 파일 정보가 리셋된다.

유닉스 프로세스 계층 구조

커널이 메모리에 올라와 부팅되면 커널 관련 프로세스를 여러 개 만든다. 이중에 init 프로세스가 존재하는데, 이는 전체 프로세스의 부모 프로세스가 되어 나머지 프로세스들을 init 프로세스의 자식 프로세스로 만든다. 이러한 계층 구조는 동시에 여러 작업을 처리하고 종료된 프로세스 자원을 회수하는데 유용하다.
 
고아 프로세스 : 부모 프로세스가 먼저 종료되거나 자식 프로세스가 비정상적으로 종료되면 부모 프로세스와의 연결이 끊기게 된다. 이로 인해 자식 프로세스가 종료되지 않거나 종료되어도 자원이 남게되는 프로세스를 고아 프로세스라고 한다. 그러므로 운영체제는 이러한 고아 프로세스에서 반환되지 못한 자원을 주기적으로 회수해야한다.

프로세스는 코드, 데이터, 스택 영역으로 이루어져 있는데 코드, 데이터 영역은 정적 할당 영역, 힙 영역과 스택 영역은 동적 할당 영역으로 구분된다. 

스택은 되돌아올 메모리 주소를 스택에 저장하고 함수 호출과 복귀에 사용된다. 또한 변수 사용 범위 영역을 구현할 때도 사용된다. 함수에서 사용되는 지역 변수는 함수가 호출될 때 사용되다가 함수가 종료되면 사용 공간을 반환하는데, 지역 변수를 저장할 때 스택을 사용한다. 스레드가 작동하는 동안 추가되거나 삭제되는 동작 할당 영역이다.

힙은 동적을 할당되며 일부 데이터는 프로그램이 실행되는 동안 힙 영역에 할당된다. 대표적으로 malloc()함수가 있다. 정적으로 할당된 데이터는 사용유무와 관계없이 메모리를 차지하지만 동적 영역의 데이터는 필요할 때만 차지하고 필요없어지면 free()함수를 통해 메모리를 반환할 수 있게 된다.

exit() : 프로세스를 종료시키며 리턴값이 0이면 정상 종료, -1이면 비정상 종료이다.
wait() : 고아 프로세스를 방지하기 위해 자식 프로세스가 끝날 때까지 기다려 부모 프로세스가 먼저 종료되는 것을 방지한다.