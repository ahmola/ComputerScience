프로세스가 생성되면 CPU스케줄러가 CPU에 전달하는 작업 하나가 스레드이다. 즉, CPU의 일 처리 단위는 프로세스로부터 받은 스레드이며, 프로세스가 CPU에 작업 요청을 하는 실행 단위

job > task(process) > operation(thread) 순으로 작업의 크기가 된다.

프로세스끼리는 약하게 연결되어 있지만 스레드끼리는 프로세스 내부에서 강하게 연결되어 있다.

멀티스레드 : 프로세스 내 작업을 여러 개의 스레드로 분할함. 멀티스레드는 변수나 파일 등을 공유하고 전역 변수나 함수 호출 등의 방법으로 스레드 간 통신을 한다. 시분할 시스템에서 운영체제가 CPU의 작업은 프로세스가 아닌 스레드다. 그리고 이러한 특성을 활용하여 파이프라인 기법을 통해 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법인 CPU 멀티스레드가 있다.

fork() 시스템 호출로 프로세스를 복사하면 내용이 중복되어 낭비가 발생한다. 이러한 낭비를 막기위해 스레드가 사용되어 코드와 데이터 등을 공유하여 여러 개의 일을 하나의 프로세스 내에서 하는 것이다. 프로세스 내에서 여러 개의 스레드를 만들어 사용하여 자원을 공유하여 자원 낭비를 막고 효율성을 향상한다. 스레드는 가벼운 프로세스라고 부르는데 만약 스레드가 1개인 일반 프로세스는 무거운 프로세스라고 불린다,
그러나 스레드는 강하게 연결되어 있어 하나의 스레드가 잘못되면 전체 프로세스에 영향을 미치게 된다.

멀티스레드 모델

    커널 스레드 : 커널이 직접 생성하고 관리. 커널이 멀티스레드를 지원하므로 1 to 1모델이라고 한다. 독립적인 특성으로 한 스레드가 대기 상태에 들어가도 다른 스레드는 작업할 수 있다. 커널 레벨에서 모든 작업을 지원하므로 멀티 CPU를 사용할 수 있고, 다른 스레드도 작업을 할 수 있고, 보안에 강하고 안정적이다. 그러나 문맥 교환 시 오버헤드로 성능 저하.

    사용자 스레드 :  라이브러리에 의한 구현으로 라이브러리가 스케줄링이나 동기화 같은 기능을 대신 구현하게 되는데, 이는 커널한테 스레드가 프로세스처럼 보이게 된다. 이렇게 구현된 여러 개의 스레드는 커널의 스레드 하나와 연결되어 있어서 1 to N모델이라고 한다. 라이브러리가 직접 스케줄링을 하므로 문맥 교환이 필요없어 속도가 빠르지만 하나의 스레드가 대기하면 모든 스레드가 대기하게 되고 프로세스의 time slice를 여러 스레드가 공유하므로 CPU를 동시에 사용할 수 없게 된다. 또한 보안에 취약하다.