프로그래밍 언어(고급언어) : 문제를 풀기 위해 일련의 과정을 기술하는 데 사용하는 언어
기계어 : 0과1로 구성된 2진법
어셈블리어 : 프로그래밍 언어를 기계어로 바꾸기 위한 중간 단계의 언어. ADD, LOAD등의 명령어를 사용

컴파일러 : 고급언어로 작성된 프로그램을 기계어로 번역하는 소프트웨어

컴파일 과정

    1. 어휘분석 : 원시 프로그램을 읽어서 프로그램 문장의 최소 단위인 어휘(토큰)를 하나씩 분석하여 문법에 알맞은지 확인. 어휘는 IF같은 예약어나 연산자, 식별자, 괄호, 세미콜론 등이 있다.

    2. 구문분석 : Parsing이라고도 함. 토큰을 입력받아 문장 구조가 올바른지 판독. 올바르다면 구문구조를 출력하고 틀리면 오류메시지를 출력함. 토큰을 단말노드로하는 트리 형태로 표현한 parse tree라고 함. 여기서 불필요한 정보를 제거한 syntex tree를 만든다.

    3. 의미분석 : syntex tree의 의미와 기능을 분석하고 수행 환경을 조성. 연산자가 허용된 피연산자를 가졌는지 판별하는 tree checking이 진행됨

    4. 중간 코드 생성 : syntex tree를 사용해서 문법규칙이 줄어들 때마다 규칙에 맞게 중간코드를 생성한다. 쿼드러플로 표현함
    ex) a = b + c -> (+, b, c, a)

    5. 코드최적화 : 코드 실행 시 기억공간과 실행시간 절약. 생략되는 경우도 있음. 지역최적화, 전역최적화, 단일문 최적화, 루프 최적화가 있음

    6. 목적코드 생성 : 마지막 단계, 연산을 수행할 레지스터를 선택하거나 저장할 기억장소의 위치를 정하고, 기계어에 대한 코드를 생성.
    중간코드를 기계명령어로 바꿈

입력 프로그램 전체 문장을 입력된 순서대로 처리하여, 전체적인 하나의 목적 프로그램으로 완성하고 후에 LOAD하여 실행

인터프리터는 입력 프로그램의 논리 순서로 문장 단위를 번역한 후, 곧바로 실행하여 컴퓨터와의 대화가 가능함. 시뮬레이션 기법이라고도 함
일반적으로 컴파일 기법과 인터프리터 기법을 혼합하여 사용

반복 처리가 잦은 프로그램은 컴파일 기법이 효과적. 그러나 프로그램에 따라서 기계어가 기하급수적으로 늘어나 기억장소가 필요해질 수 있다.
반대로 인터프리터는 하나씩 번역하므로 큰 기억장소가 요구되지는 않지만 반복문을 계속 해석하게되어 실행 시간이 길어지게 된다.

컴파일러는 논리적 구조와 물리적 구조로 분류됨
논리적 구조는 위 컴파일 과정과 같음

물리적 구조는 논리적 구조와 항상 일치하지 않음. 컴파일러 구현 시에 여러 단계를 하나의 모듈로 묶는 pass라는 방법이 있다.
컴파일 전 과정을 하나의 패스로 구현한 1-pass 컴파일러와 중간코드를 기점으로 앞 단계를 전반부, 뒷 단계를 후반부로 구성한 2-pass 컴파일러가 존재함.