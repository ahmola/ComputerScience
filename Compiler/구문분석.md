구문분석 : 주어진 규칙에 구문구조가 맞는지 검사

구문분석 방법 : top-down(루트노드를 시작으로 터미널 노드를 만듦, 좌단유도), bottom-up(터미널 노드로부터 루트노드를 향해 만들어짐,우단유도)

bottom-up : 문자열로부터 reduce에 의해 시작기호를 찾아가는 방법
    
    S => aAw => aBw에서 A를 B로 바꾸는 것을 reduce라고 한다. 또한 B를 문장형태 aBw의 handle이라고 한다.
    즉, reduce되는 부분을 handle이라고 한다.

    S => r0 => r1 => r2 => ... => rn-1 => n = w의 우단유도 과정에서, 각 ri의 문장형태에서 handle을 찾아 ri-1로 가면서 시작기호로 reduce되는 과정을 handle pruning이라고 한다.

shift-reduce : 스택과 입력 버퍼를 사용하여 구현. 스택은 handle을 찾을 때까지 입력기호를 유지하고 입력버퍼는 주어진 문자열 간직
스택의 top에 handle이 나타날 때까지 입력기호를 하나씩 스택으로 옮김(shift)
shift를 계속하다가 handle이 발견되면, 문자열이 생성규칙 오른쪽에 있는 것을 찾아 왼쪽 기호로 reduce
만약 handle이 발견되지 않으면 오류메시지가 난다.
shift(입력기호를 스택에 옮김), reduce(handel이 스택 top에 놓이면 handle을 찾아 기호로 대체), accept(주어진 문법에 맞는 문장인지 나타냄), error(입력기호를 나타낼 수 없을 때 틀린 문장임을 나타냄) 네 가지 행동을 함

shift-reduce 구문분석은 handle을 어떻게 찾고 생성규칙이 여러 개라면 어떤 것을 적용할 지에 대한 문제점이 내포 => 순위문법 등장

순위문법 종류

    연산자순위 문법 : ε-생성규칙을 갖지 않고, 생성규칙의 오른쪽에 두 개 이상의 논터미널이 연속해서 나올 수 없다.
    단순순위 문법 : ε-생성규칙을 갖지 않고, 오른쪽 부분이 같은 생성규칙이 존재하지 않으며, 한 개 이하의 Wirth-Weber 순위관계를 갖는다.
    확장순위 문법 : ε-생성규칙을 갖지 않고, 오른쪽 부분이 같은 생성규칙은 존재하지 않으며, |x|= m, |y|=n인, 두 문자열 x, y 사이에 많아야 한 개의 확장순위 관계를 갖는다.
    한정순위 문법 : ε-생성규칙을 갖지 않고, 오른쪽 부분이 같은 생성규칙은 존재하지 않으며, 한 개 이하의 ⋗관계의 Wirth-Weber 순위 관계를 갖는다.
    혼합순위 문법 : handle의 tail을 먼저 찾고, 생성규칙 중 오른쪽 부분이 같은 것이 존재하면 입력 문자열의 local context를 이용한다.

논터미널 A가 ε를 유도할 수 있으면, A를 nullable하다고 한다. A *=> ε이면 nullable하다.

LR 구문분석 : 입력 문자열을 왼쪽에서 오른쪽으로 읽어가며 출력으로 우파스를 생성한다.

    1. LR 구문분석기는 모호하지 않은 context-free문법으로 쓰인 모든 프로그래밍 언어에 대해서 구성이 가능하다.
    2. LR 구문분석 방법은 가장 일반적인 backtracking없는 shift-reduce 구문분석 기법이다
    3. LR 구문분석기는 입력이 왼쪽에서 오른쪽으로 검사될 때, 구문론적인 오류를 쉽게 발견할 수 있다.

구동기 프로그램과 action과 goto를 갖는 파싱표로 구성된다.
LR(k) 문법 : 모든 엔트리에 대해 유일하게 정의되는 파싱표를 만들 수 있는 문법. k는 lookahead의 길이, handle을 결정하는 데 k개의 입력기호에 이르기까지 조사한다는 것을 의미함.
LR 파싱표는

    1. LR(0) 항목의 집합과 FOLLOW로부터 파싱을 만드는 방법인 SLR 방법. LR(0)는 오른쪽 생성규칙에 점기호를 가짐. 점기호 다음 기호를 마크기호라고함
    2. LR(1) 항목의 집합으로부터 파싱표를 만드는 방법인 Canonical LR
    3. LR(0) 항목의 집합과 lookahead로부터 또는 LR(1) 항목의 집합으로부터 구성하는 방법인 LookAhead LR(LALR) 방법 등이다.


Top-Down 분석기법 : 시작기호로부터 생성규칙 유도, 생성규칙이 오류가 발생 시 문자열 다시 검사하여 다른 생성규칙을 만들어 유도(backtracking). 입력기호를 여러번 검사하므로 시간이 매우 오래걸려 실제 컴파일러에 적용하기 힘듦

    1. 시작기호 첫 번째 생성규칙 적용
    2. 생성된 문장형태의 문자열과 입력을 차례로 비교
    3. 논터미널이 생성된 문자열이 나오면, 첫번째 생성규칙 적용, 유도된 문자열이 입력과 같으면 계속 비교
    4. 비교한 두 기호가 다르면, 생성규칙 오류이므로 생성규칙을 제거하고 다른 생성규칙 적용. 제거된 생성규칙에서 보았던 기호의 개수만큼 입력기호 뒤로 이동
    5. 더 이상 적용할 생성규칙이 없는 경우 틀린 문장이고, 문장형태에 나타난 문자열이 주어진 문자열에 이르면 올바른 문장으로 인식한다.

문법이 left-recursion을 가지면 무한 루프에 빠질 수도 있고, 같은 기호들을 prefix로 두 개 이상의 생성규칙이 존재하면 효율이 떨어짐

    해결법
    1. left-factoring으로 backtracking 제거
    2. left-recursion 발생 시 right-recursion으로 교체

Top-Down 기법 종류

    resursive-descent 구문분석 : recursive procedure의 집합을 사용, 생성규칙 lookahead 사용(strong LL). 터미널의 프로시저는 생성규칙이 있는 터미널 기호와 입력기호가 같은지를 비교하여 같다면 다음 입력기호를 볼 수 있도록 구성.
    predictive 구문분석 : 구문분석기를 바꾸지 않고 파싱표만 고쳐서 구문분석기 구현. 입력버퍼와 스택, 구동기 프로그램으로 구성. 출력은 좌파스. pop(top기호 제거하고 입력버퍼의 제어가 오른쪽으로 한 자리 이동), expand(생성규칙 왼쪽 기호 대신 오른쪽 문자열로 대체), accept(모두 $기호인 경우 올바른 문자열. 스택 초기 상태는 $$, 입력문자열은 w$), error(현재 보고있는 기호 유도 불가능) 네 가지 행동을 취함.


YACC : LEX 상위 단계에 위치, 문법규칙의 수행코드를 일반 프로그래밍 언어로 기술할 수 있음. LEX로 만든 토큰 관계로 구문분석기 생성, LEX의 yylex()를 내부적으로 호출. YACC가 yyparse()호출하면 내부적으로 yylex()를 호출하여 토큰을 요구하고 받아내어 주어진 문법에 부합하는지를 점검. 여기서 문법은 토큰 관계의 정의이고, 이러한 문법규칙에 토큰들이 맞는지 확인하는 과정을 파싱이라고 한다.

    선언 부분(토큰 선언)
    %%
    변환규칙 부분(문법규칙과 수행코드)
    %%
    사용자 프로그램 부분(복사될 C코드, yyparse()호출)
