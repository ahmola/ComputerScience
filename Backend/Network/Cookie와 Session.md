# 등장 배경

HTTP는 기본적으로 statless 프로토콜이다.

즉, 상태를 저장하지 않고 클라이언트가 서버에 요청을 보내면 서버가 받아서 응답을 보내주는 구조로,

이전 요청과 다음 요청 간의 연관성이 유지되지 않는다.

이로 인해, 발생하는 문제가 있는데 대표적인 예로,

사용자가 로그인한 뒤에 보내는 요청에서,

서버는 로그인한 유저의 정보를 저장하지 않아 해당 요청이 로그인한 유저의 것인지 알 수가 없다.

그래서 등장한 것이 쿠키와 세션이다.

사용자의 상태를 유지하기 위한 상태 관리 메커니즘이다.

## Cookie(클라이언트 상태 저장)

쿠키는 서버가 클라이언트(브라우저)에 4KB이하의 작은 데이터 조각을 저장하도록 하는 메커니즘이다.

쿠키에는 인증여부, 사용자 설정 정보, 인증 토큰, 세션ID(사용자 인식) 등이 저장된다.

이렇게 저장된 쿠키는 서버에 요청 전송 시 함께 서버로 전달된다.

- 동작 방식

    1. 클라이언트가 서버에 요청을 보냄

    2. 서버가 헤더에 Set-Cookie를 포함시킴

    3. 클라이언트가 해당 쿠키를 로컬에 저장

    4. 이후 요청마다 클라이언트는 쿠키에 필요한 정보를 담아서 헤더에 쿠키를 담아서 전송

보안에 취약하며 탈취 위험이 있음

## Session (서버 측 상태 저장)

세션은 사용자 상태 정보를 서버에서 관리하는 방식이다.

클라이언트에는 개별 세션 식별자(Session ID)만 저장하고, 나머지 정보는 서버 DB와 메모리에 저장한다.

- 동작 방식

    1. 클라이언트가 작업 요청

    2. 서버에서 세션 생성, 메모리에 저장

    3. 클라이언트에서 세션 ID를 쿠키에 담아 전송

    4. 서버는 세션ID를 통해 저장된 세션 데이터를 찾아서 상태 유지

기본적으로 메모리를 사용하여 저장하나 분산 환경에서는 DB와 함께 사용함.

실제 정보가 서버에 저장되므로 훨씬 안전하지만 유지보수가 힘듦

서버 자원을 사용하기에 상대적으로 느리다.

그러나 근본적으로 세션ID가 탈취당하면 안전하지 못하므로,

JWT(Json Web Token)을 OAuth2 서버에서 발급받아

사용자 인증 토큰을 Authentication 헤더에 담아서 보내고

각종 추가적인 노출되어도 상관없는 사용자 설정 정보는 세션으로 관리한다.

이러한 세션도 캐시서버(Redis 등)으로 대체되었다.

즉, 백엔드 서버 자체에는 세션을 두지 않고 statless상태에서 토큰 검증만을 수행하며,

JWT + Redis를 활용하고 설정값등은 쿠키로 프론트엔드 페이지에 저장한다.

JWT는 로그아웃 처리가 어렵기 때문에 Redis에 블랙리스트로 등록하여 막는다.